name: ArtShare Backend CI/CD

on:
  push:
    branches: ['main']
  pull_request:
    branches: ['main']

env:
  DOCKER_IMAGE: artshare-backend
  CONTAINER_NAME: backend

jobs:
  # Build and Test Job (your existing logic with improvements)
  build-and-test:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Use Node.js 22
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'yarn'

      - name: Install Dependencies
        run: yarn install --frozen-lockfile

      - name: Run Linting
        run: yarn lint

      - name: Run Formatting Check
        run: yarn format

      - name: Audit Dependencies
        run: yarn audit --level=high
        continue-on-error: true

      - name: Build Project (Production)
        env:
          NODE_ENV: production
        run: |
          set -e
          yarn build
          if [ ! -d "dist" ] && [ ! -d "build" ]; then
            echo "Build output directory not found!"
            exit 1
          fi

      - name: Build Docker Image
        run: |
          docker build \
            -t ${{ env.DOCKER_IMAGE }}:${{ github.sha }} \
            -t ${{ env.DOCKER_IMAGE }}:test .

      - name: Debug Branch Info
        run: |
          echo "Event name: ${{ github.event_name }}"
          echo "Ref: ${{ github.ref }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Is main branch: ${{ github.ref == 'refs/heads/main' }}"

      - name: Upload Docker Image Artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-${{ github.sha }}
          path: docker-image.tar.gz
          retention-days: 7

      - name: Test Docker Container
        run: |
          # Test container can start
          docker run -d --name test-container \
            -p 3001:3000 \
            -e NODE_ENV=production \
            -e DATABASE_URL="postgresql://test:test@localhost:5432/test" \
            ${{ env.DOCKER_IMAGE }}:test \
            sh -c "echo 'Container test successful' && sleep 10"
          
          sleep 5
          docker logs test-container
          docker stop test-container || true
          docker rm test-container || true

  # Deploy Job (only runs on main branch push)
  deploy:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
      # Step 1: Download the image file created in the previous job.
      - name: Download Docker Image Artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image-${{ github.sha }}

      # Step 2: Copy the image file to a temporary location on your server.
      - name: Copy Image to Server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.DO_HOST }}
          username: root
          key: ${{ secrets.DO_SSH_KEY }}
          source: "docker-image.tar.gz"
          target: "/tmp"

      # Step 3: Run the combined deployment, verification, and notification script.
      - name: Deploy, Verify, and Notify
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DO_HOST }}
          username: root
          key: ${{ secrets.DO_SSH_KEY }}
          envs: GITHUB_SHA, DOCKER_IMAGE, CONTAINER_NAME
          script: |
            # This script will run the main deployment logic.
            # If it succeeds, it runs the success notification.
            # If any command fails, it runs the failure notification.
            
            # Function for the main deployment logic
            deploy_and_verify() {
              set -e # Exit this function immediately if a command fails
              
              echo "üöÄ Starting deployment for commit: $GITHUB_SHA"
              
              echo "üì¶ Loading Docker image from /tmp/docker-image.tar.gz..."
              docker load -i /tmp/docker-image.tar.gz
              
              # Start of your proven zero-downtime deployment logic
              TEMP_CONTAINER="${CONTAINER_NAME}-new"
              echo "üöÄ Starting new container: $TEMP_CONTAINER"
              
              docker rm -f $TEMP_CONTAINER 2>/dev/null || true # Ensure no stale temp container exists
              
              docker run -d --name $TEMP_CONTAINER \
                --restart=unless-stopped \
                --cap-drop=ALL --cap-add=CHOWN --cap-add=SETGID --cap-add=SETUID --security-opt=no-new-privileges:true \
                -p 127.0.0.1:3001:3000 \
                --env-file /root/ArtShare-BE/.env \
                ${DOCKER_IMAGE}:latest
              
              echo "‚è≥ Waiting for new container to be ready (up to 60s)..."
              sleep 10 # Initial grace period
              
              # Health check and verification loop
              for i in {1..25}; do
                # Check that the container is running and healthy via curl
                if docker exec $TEMP_CONTAINER curl -f http://localhost:3000/health >/dev/null 2>&1; then
                  echo "‚úÖ Verification successful: New container is healthy."
                  
                  # Stop the old container if it's running
                  if docker ps | grep -q "$CONTAINER_NAME"; then
                    echo "üõë Stopping old container..."
                    docker stop $CONTAINER_NAME
                    docker rm $CONTAINER_NAME
                  fi
                  
                  # Rename the new container to the final name and restart it on the correct port
                  echo "üîÑ Switching to the new container on port 3000..."
                  docker stop $TEMP_CONTAINER
                  docker rm $TEMP_CONTAINER
                  
                  docker run -d --name $CONTAINER_NAME \
                    --restart=unless-stopped \
                    --cap-drop=ALL --cap-add=CHOWN --cap-add=SETGID --cap-add=SETUID --security-opt=no-new-privileges:true \
                    -p 127.0.0.1:3000:3000 \
                    --env-file /root/ArtShare-BE/.env \
                    ${DOCKER_IMAGE}:latest
                  
                  # If we reach this point, the entire process was a success.
                  return 0
                fi
                echo "Waiting for health check... ($i/25)"
                sleep 2
              done
              
              # If the loop finishes, the health check failed.
              echo "‚ùå Verification failed: New container did not become healthy in time."
              echo "Logs from failed container:"
              docker logs $TEMP_CONTAINER
              docker rm -f $TEMP_CONTAINER
              return 1 # Explicitly return a failure code
            }

            # --- Main Execution Block ---
            # Try to run the deployment function. Based on the result, run the correct notification.
            if deploy_and_verify; then
              # Success Notification
              echo "üéâ Deployment of commit $GITHUB_SHA completed successfully!"
              echo "üìä Current status:"
              docker ps | grep $CONTAINER_NAME
              echo "üîó Application should be available at your domain"
              
              # Cleanup the temporary image file
              echo "üßπ Cleaning up..."
              rm /tmp/docker-image.tar.gz
              docker image prune -f
            else
              # Failure Notification
              echo "‚ùå Deployment failed for commit $GITHUB_SHA"
              echo "üìä Current container status:"
              docker ps -a | grep $CONTAINER_NAME || echo "No backend container found"
              # Cleanup the temporary image file even on failure
              rm /tmp/docker-image.tar.gz
              exit 1 # Make sure the GitHub Actions step is marked as failed
            fi