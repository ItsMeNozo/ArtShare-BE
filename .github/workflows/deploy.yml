# .github/workflows/deploy.yml
name: ArtShare Backend Deploy

on:
  push:
    branches: ['main']

env:
  REGISTRY: registry.digitalocean.com/art-share
  IMAGE_NAME: artshare-backend
  DOCKER_IMAGE: artshare-backend
  CONTAINER_NAME: backend

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Deploy to Digital Ocean
        uses: appleboy/ssh-action@v1.0.3
        env:
          GITHUB_SHA: ${{ github.sha }}
          REGISTRY: ${{ env.REGISTRY }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          DOCKER_IMAGE: ${{ env.DOCKER_IMAGE }}
          CONTAINER_NAME: ${{ env.CONTAINER_NAME }}
        with:
          host: ${{ secrets.DO_HOST }}
          username: root
          key: ${{ secrets.DO_SSH_KEY }}
          envs: GITHUB_SHA,REGISTRY,IMAGE_NAME,DOCKER_IMAGE,CONTAINER_NAME
          script: |
            set -e
            
            echo "ğŸš€ Starting deployment for commit: $GITHUB_SHA"
            echo "ğŸ“¦ Using pre-built image from registry"
            
            # Log in to registry
            echo "${{ secrets.DIGITALOCEAN_REGISTRY_TOKEN }}" | docker login $REGISTRY -u "${{ secrets.DIGITALOCEAN_REGISTRY_TOKEN }}" --password-stdin
            
            # Navigate to project directory
            cd ArtShare-BE/
            
            # Backup current state for rollback
            echo "ğŸ“¦ Creating backup of current deployment..."
            BACKUP_IMAGE="${DOCKER_IMAGE}:backup-$(date +%s)"
            if docker images | grep -q "${DOCKER_IMAGE}:latest"; then
              docker tag ${DOCKER_IMAGE}:latest $BACKUP_IMAGE
              echo "Backup created: $BACKUP_IMAGE"
            fi
            
            # Pull the pre-built image (NO BUILDING!)
            echo "ğŸ“¥ Pulling pre-built image..."
            docker pull $REGISTRY/$IMAGE_NAME:latest
            
            # Tag the registry image as our local latest
            docker tag $REGISTRY/$IMAGE_NAME:latest ${DOCKER_IMAGE}:latest
            
            # Function to rollback on failure
            rollback() {
              echo "âŒ Deployment failed, rolling back..."
              if docker images | grep -q "$BACKUP_IMAGE"; then
                docker tag $BACKUP_IMAGE ${DOCKER_IMAGE}:latest
                echo "Rollback image restored"
              fi
              exit 1
            }
            
            # Health check function
            health_check() {
              echo "ğŸ” Performing health check..."
              for i in {1..30}; do
                if docker exec $CONTAINER_NAME curl -f http://localhost:3000 2>/dev/null; then
                  echo "âœ… Health check passed"
                  return 0
                fi
                echo "Waiting for application to start... ($i/30)"
                sleep 2
              done
              echo "âŒ Health check failed"
              return 1
            }
            
            # Zero-downtime deployment strategy
            echo "ğŸ”„ Starting zero-downtime deployment..."
            
            # Start new container with temporary name
            TEMP_CONTAINER="${CONTAINER_NAME}-new"
            
            echo "ğŸš€ Starting new container: $TEMP_CONTAINER"
            docker run -d --name $TEMP_CONTAINER \
              --restart=unless-stopped \
              --cap-drop=ALL \
              --cap-add=CHOWN \
              --cap-add=SETGID \
              --cap-add=SETUID \
              --security-opt=no-new-privileges:true \
              -p 127.0.0.1:3001:3000 \
              --env-file .env \
              --entrypoint sh ${DOCKER_IMAGE}:latest \
              -c "npx prisma migrate deploy && node dist/src/main.js" || rollback
            
            # Wait for new container to be ready
            echo "â³ Waiting for new container to be ready..."
            sleep 10
            
            # Check if new container is running
            if ! docker ps | grep -q $TEMP_CONTAINER; then
              echo "âŒ New container failed to start"
              docker logs $TEMP_CONTAINER
              docker rm -f $TEMP_CONTAINER 2>/dev/null || true
              rollback
            fi
            
            # Test new container
            echo "ğŸ” Testing new container..."
            for i in {1..30}; do
              if docker exec $TEMP_CONTAINER curl -f http://localhost:3000 2>/dev/null; then
                echo "âœ… New container is healthy"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "âŒ New container health check failed"
                docker logs $TEMP_CONTAINER
                docker rm -f $TEMP_CONTAINER
                rollback
              fi
              echo "Waiting for new container... ($i/30)"
              sleep 2
            done
            
            # Stop old container and start new one on correct port
            echo "ğŸ”„ Switching to new container..."
            
            # Stop old container
            if docker ps | grep -q "$CONTAINER_NAME"; then
              docker stop $CONTAINER_NAME
              docker rm $CONTAINER_NAME
            fi
            
            # Stop temp container
            docker stop $TEMP_CONTAINER
            docker rm $TEMP_CONTAINER
            
            # Start final container on production port
            echo "ğŸš€ Starting production container..."
            docker run -d --name $CONTAINER_NAME \
              --restart=unless-stopped \
              --cap-drop=ALL \
              --cap-add=CHOWN \
              --cap-add=SETGID \
              --cap-add=SETUID \
              --security-opt=no-new-privileges:true \
              -p 127.0.0.1:3000:3000 \
              --env-file .env \
              --entrypoint sh ${DOCKER_IMAGE}:latest \
              -c "npx prisma migrate deploy && node dist/src/main.js" || rollback
            
            # Final health check
            sleep 10
            if ! health_check; then
              rollback
            fi
            
            # Clean up old images (keep last 3)
            echo "ğŸ§¹ Cleaning up old Docker images..."
            docker images $DOCKER_IMAGE --format "table {{.Repository}}:{{.Tag}}\t{{.CreatedAt}}" | \
              grep -v "latest\|backup" | \
              tail -n +4 | \
              awk '{print $1}' | \
              xargs -r docker rmi || true
            
            echo "âœ… Deployment completed successfully!"
            echo "ğŸ“Š Container status:"
            docker ps | grep $CONTAINER_NAME
            
            echo "ğŸ“ Recent logs:"
            docker logs --tail 20 $CONTAINER_NAME

      - name: Verify Deployment
        uses: appleboy/ssh-action@v1.0.3
        env:
          CONTAINER_NAME: ${{ env.CONTAINER_NAME }}
        with:
          host: ${{ secrets.DO_HOST }}
          username: root
          key: ${{ secrets.DO_SSH_KEY }}
          envs: CONTAINER_NAME
          script: |
            # Final verification
            echo "ğŸ” Final deployment verification..."
            
            # Check container is running
            if ! docker ps | grep -q "$CONTAINER_NAME"; then
              echo "âŒ Container is not running!"
              exit 1
            fi
            
            # Check application responds
            sleep 5
            if docker exec $CONTAINER_NAME curl -f http://localhost:3000 >/dev/null 2>&1; then
              echo "âœ… Application is responding"
            else
              echo "âŒ Application is not responding"
              echo "Container logs:"
              docker logs --tail 50 $CONTAINER_NAME
              exit 1
            fi
            
            echo "ğŸ‰ Deployment verification successful!"

      - name: Notify Deployment Success
        if: success()
        run: |
          echo "ğŸ‰ Deployment of commit ${{ github.sha }} completed successfully!"
          echo "ğŸ“¦ Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"

      - name: Notify Deployment Failure
        if: failure()
        run: |
          echo "âŒ Deployment failed for commit ${{ github.sha }}"