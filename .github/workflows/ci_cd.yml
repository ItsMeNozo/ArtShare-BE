# .github/workflows/ci_cd.yml
name: ArtShare Backend CI/CD

on:
  push:
    branches: ['main']
  pull_request:
    branches: ['main']

# Environment variables available to all jobs
env:
  REGISTRY: docker.io
  IMAGE_NAME: itsmestarlight/artshare-backend
  DOCKER_IMAGE: artshare-backend
  CONTAINER_NAME: backend
  VOLUME_NAME: artshare_model_cache

jobs:
  # ==================================
  #      CI Job: Build and Test
  # ==================================
  # This job runs on every push and PR to main.
  # It builds the app, runs checks, and pushes a Docker image.
  build-and-test:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: test
        ports:
          - 5432:5432 # Expose port 5432 on the runner
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Use Node.js 22
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'yarn'

      - name: Install Dependencies
        run: yarn install --frozen-lockfile

      - name: Run Linting & Formatting
        run: |
          yarn lint
          yarn format

      - name: Audit Dependencies
        run: yarn audit --level=high
        continue-on-error: true

      - name: Build Project (Production)
        env: { NODE_ENV: production }
        run: yarn build

      - name: Build Docker Image
        run: |
          # Build with layer caching for faster builds
          docker build \
            --cache-from ${{ env.IMAGE_NAME }}:latest \
            -t ${{ env.IMAGE_NAME }}:test .

      - name: Verify Container in a Production-like Environment
        run: |
          echo "ğŸ§ª Starting full container verification..."


          # Run the container, connecting it to the service database
          # The container's entrypoint.sh will automatically run migrations
          docker run -d --name test-container \
            -p 3000:3000 \
            -e DATABASE_URL=postgresql://test:test@localhost:5432/test \
            ${{ env.IMAGE_NAME }}:test

          # Wait for the application to become healthy
          echo "â³ Waiting for container to start and pass health check..."
          sleep 10  # Initial wait for container to start
          for i in {1..30}; do
            if docker exec $CONTAINER_NAME curl -f http://localhost:3000/ >/dev/null 2>&1; then
              echo "âœ… Container is healthy and responding!"
              docker logs test-container
              docker stop test-container
              exit 0
            fi
            echo "Waiting... (attempt $i/30)"
            sleep 5
          done

          echo "âŒ Container verification failed!"
          docker logs test-container
          docker stop test-container
          exit 1

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Push to Docker Hub
        # This step only runs on pushes to main to protect the 'latest' tag
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          SHORT_SHA=$(git rev-parse --short HEAD)
          docker tag ${{ env.IMAGE_NAME }}:test ${{ env.IMAGE_NAME }}:${SHORT_SHA}
          docker tag ${{ env.IMAGE_NAME }}:test ${{ env.IMAGE_NAME }}:${{ github.sha }}
          docker tag ${{ env.IMAGE_NAME }}:test ${{ env.IMAGE_NAME }}:latest
          echo "ğŸ“¤ Pushing the following tags: latest, ${SHORT_SHA}, ${{ github.sha }}"
          docker push --all-tags ${{ env.IMAGE_NAME }}

      - name: Report Status
        run: echo "âœ… CI Job Completed."

  # ==================================
  #      CD Job: Deploy
  # ==================================
  # This job runs ONLY after 'build-and-test' succeeds on a push to 'main'.
  deploy:
    runs-on: ubuntu-latest
    needs: build-and-test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - name: Deploy to Digital Ocean
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DO_HOST }}
          username: root
          key: ${{ secrets.DO_SSH_KEY }}
          envs: GITHUB_SHA,REGISTRY,IMAGE_NAME,DOCKER_IMAGE,CONTAINER_NAME,VOLUME_NAME
          script: |
            set -e

            echo "ğŸš€ Starting deployment for commit: $GITHUB_SHA"

            echo "ğŸ“¦ Ensuring cache volume '${VOLUME_NAME}' exists..."
            docker volume create ${VOLUME_NAME} || true

            # Navigate to project directory
            cd ArtShare-BE/

            # Memory cleanup before deployment
            echo "ğŸ§¹ Cleaning up memory and Docker cache..."
            docker stop $CONTAINER_NAME 2>/dev/null || true
            docker rm $CONTAINER_NAME 2>/dev/null || true
            docker system prune -af || true
            sync && echo 3 > /proc/sys/vm/drop_caches || true

            echo "ğŸ’¾ Available memory after cleanup:"
            free -h

            # Create backup
            echo "ğŸ“¦ Creating backup of current deployment..."
            BACKUP_IMAGE="${DOCKER_IMAGE}:backup-current"
            if docker images | grep -q "${DOCKER_IMAGE}:latest"; then
              docker rmi ${DOCKER_IMAGE}:backup-current 2>/dev/null || true
              docker tag ${DOCKER_IMAGE}:latest $BACKUP_IMAGE
              echo "Backup created: $BACKUP_IMAGE"
            fi

            # Pull fresh image
            echo "ğŸ“¥ Pulling latest image from Docker Hub..."
            docker pull $IMAGE_NAME:latest
            docker tag $IMAGE_NAME:latest ${DOCKER_IMAGE}:latest

            # Rollback function
            rollback() {
              echo "âŒ Deployment failed, rolling back..."
              if docker images | grep -q "${DOCKER_IMAGE}:backup-current"; then
                docker tag ${DOCKER_IMAGE}:backup-current ${DOCKER_IMAGE}:latest
                echo "âœ… Rollback completed"
                return 0
              else
                echo "âš ï¸ No backup available"
              fi
              exit 1
            }

            # Simple deployment - stop old, start new
            echo "ğŸš€ Starting new container..."
            docker run -d --name $CONTAINER_NAME \
              --restart=unless-stopped \
              --cap-drop=ALL \
              --cap-add=CHOWN \
              --cap-add=SETGID \
              --cap-add=SETUID \
              --security-opt=no-new-privileges:true \
              -p 127.0.0.1:3000:3000 \
              --env-file .env \
              -e OMP_NUM_THREADS=2 \
              -e ONNX_DISABLE_OPTIMIZATION=1 \
              -v ${VOLUME_NAME}:/app/.cache \
              --no-healthcheck \
              ${IMAGE_NAME}:latest || rollback

            # Wait for app to start (longer for AI model loading)
            echo "â³ Waiting for application to start (including AI models)..."
            sleep 60 

            # Health check with much longer timeout for AI loading
            echo "ğŸ” Performing health check..."
            for i in {1..120}; do  # 4 minutes total timeout
              if docker exec $CONTAINER_NAME curl -f http://localhost:3000/ >/dev/null 2>&1; then
                echo "âœ… Health check passed"
                break
              fi
              if [ $i -eq 120 ]; then
                echo "âŒ Health check failed"
                echo "ğŸ“‹ Container logs:"
                docker logs --tail 100 $CONTAINER_NAME || true
                echo "ğŸ“Š Container stats:"
                docker stats $CONTAINER_NAME --no-stream || true
                rollback
              fi
              echo "Waiting for application to respond... ($i/120)"
              sleep 2
            done

            # Cleanup
            echo "ğŸ§¹ Cleaning up..."
            docker images | grep "${DOCKER_IMAGE}:backup-" | grep -v "backup-current" | awk '{print $3}' | xargs -r docker rmi || true
            docker image prune -f || true

            echo "âœ… Deployment completed successfully!"
            echo "ğŸ“Š Container status:"
            docker ps | grep $CONTAINER_NAME
            echo "ğŸ“ Recent logs:"
            docker logs --tail 20 $CONTAINER_NAME

      - name: Verify Deployment
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DO_HOST }}
          username: root
          key: ${{ secrets.DO_SSH_KEY }}
          envs: CONTAINER_NAME
          script: |
            echo "ğŸ” Final deployment verification..."

            # Check container is running
            if ! docker ps | grep -q "$CONTAINER_NAME"; then
              echo "âŒ Container is not running!"
              exit 1
            fi

            for i in {1..60}; do  # Longer verification timeout
              if docker exec $CONTAINER_NAME curl -f http://localhost:3000/ >/dev/null 2>&1; then
                echo "âœ… Application is responding with 'Hello World!'"
                break
              fi
              if [ $i -eq 60 ]; then
                echo "âŒ Application is not responding"
                echo "Container logs:"
                docker logs --tail 100 $CONTAINER_NAME
                echo "Container stats:"
                docker stats $CONTAINER_NAME --no-stream || true
                exit 1
              fi
              echo "Verifying application... ($i/60)"
              sleep 3
            done

            echo "ğŸ‰ Deployment verification successful!"

      - name: Notify Deployment Success
        if: success()
        run: |
          echo "ğŸ‰ Deployment of commit ${{ github.sha }} completed successfully!"
          echo "ğŸ“¦ Image: ${{ env.IMAGE_NAME }}:latest"
          echo "ğŸ’° Cost: FREE (Docker Hub public repository)"

      - name: Notify Deployment Failure
        if: failure()
        run: |
          echo "âŒ Deployment failed for commit ${{ github.sha }}"
