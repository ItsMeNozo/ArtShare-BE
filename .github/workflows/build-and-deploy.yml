name: Deploy NestJS App to DO Droplet via SCP

on:
  push:
    branches:
      - testdeploy

# Define environment variables used throughout the workflow
# IMAGE_NAME: The name for your Docker image (e.g., artshare-backend)
# CONTAINER_NAME: The name for your running Docker container on the droplet (e.g., artshare-app)
# DROPLET_PORT: The port your NestJS application listens on inside the container (e.g., 3000)
# DROPLET_TARGET_PATH: A temporary path on your droplet to copy the image tarball (e.g., /tmp or /root/deploy_images)
env:
  IMAGE_NAME: artshare-backend
  CONTAINER_NAME: artshare-app
  DROPLET_PORT: 3000 # Important: Ensure this matches your NestJS app's port
  DROPLET_TARGET_PATH: /tmp # Temporary path on the droplet for the tar file

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout source code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        id: build_image
        run: |
          IMAGE_TAG="${{ github.sha }}"
          echo "Building image: ${{ env.IMAGE_NAME }}:$IMAGE_TAG"
          docker build -t "${{ env.IMAGE_NAME }}:$IMAGE_TAG" .
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Save Docker image to tar
        id: save_tar
        run: |
          IMAGE_TAR_FILENAME="${{ env.IMAGE_NAME }}-${{ steps.build_image.outputs.image_tag }}.tar"
          echo "Saving image ${{ env.IMAGE_NAME }}:${{ steps.build_image.outputs.image_tag }} to $IMAGE_TAR_FILENAME"
          docker save "${{ env.IMAGE_NAME }}:${{ steps.build_image.outputs.image_tag }}" -o "$IMAGE_TAR_FILENAME"
          
          chmod 644 "$TAR_FILENAME"
          echo "Set permissions (644) on $TAR_FILENAME"
          
          echo "IMAGE_TAR_FILENAME=$IMAGE_TAR_FILENAME" >> $GITHUB_ENV # Make tar filename available to next steps

      - name: Verify tar file before SCP # ADD THIS ENTIRE STEP FOR DEBUGGING
        run: |
          echo "Current directory: $(pwd)"
          echo "Workspace contents:"
          ls -lha .
          echo "---"
          echo "Checking saved tar file: ${{ env.IMAGE_TAR_FILENAME_ENV }}" # Use the env var set above
          # Check if file exists and list its permissions
          ls -lha "${{ env.IMAGE_TAR_FILENAME_ENV }}"
          if [ ! -f "${{ env.IMAGE_TAR_FILENAME_ENV }}" ]; then
            echo "::error::Tar file ${{ env.IMAGE_TAR_FILENAME_ENV }} not found!"
            exit 1
          fi
          echo "Tar file exists and permissions are listed above. Should be readable (e.g., -rw-r--r--)."

      - name: Copy Docker image tar to Droplet
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.DO_USER }} # Your SSH username for the Droplet
          key: ${{ secrets.SSHKEY }}         # Your SSH private key
          source: "${{ env.IMAGE_TAR_FILENAME_ENV  }}" # The tar file created in the previous step
          target: "${{ env.DROPLET_TARGET_PATH }}"  # Directory on the Droplet to copy the tar file

      - name: Deploy on Droplet
        uses: appleboy/ssh-action@v1.0.3
        # Pass necessary variables from GitHub Actions to the script's environment on the Droplet
        env:
          REMOTE_IMAGE_NAME: ${{ env.IMAGE_NAME }}
          REMOTE_CONTAINER_NAME: ${{ env.CONTAINER_NAME }}
          REMOTE_DROPLET_PORT: ${{ env.DROPLET_PORT }}
          REMOTE_TARGET_PATH: ${{ env.DROPLET_TARGET_PATH }}
          REMOTE_IMAGE_TAR_FILENAME: ${{ env.IMAGE_TAR_FILENAME_ENV  }} # Passed from previous step
          REMOTE_IMAGE_TAG: ${{ steps.build_image.outputs.image_tag_output  }}
          REMOTE_DATABASE_URL: ${{ secrets.DATABASE_URL }} # Your database connection string
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.DO_USER }}
          key: ${{ secrets.SSHKEY }}
          # passphrase: ${{ secrets.SSH_KEY_PASSPHRASE }} # Uncomment if your SSH key has a passphrase
          port: 22
          script: |
            set -e # Exit immediately if a command exits with a non-zero status

            echo "--- Starting deployment on Droplet ---"

            FULL_IMAGE_TAR_PATH="$REMOTE_TARGET_PATH/$REMOTE_IMAGE_TAR_FILENAME"
            FULL_IMAGE_NAME_WITH_TAG="$REMOTE_IMAGE_NAME:$REMOTE_IMAGE_TAG"

            echo "Loading Docker image from $FULL_IMAGE_TAR_PATH..."
            docker load -i "$FULL_IMAGE_TAR_PATH"

            echo "Removing Docker image tar file: $FULL_IMAGE_TAR_PATH..."
            rm "$FULL_IMAGE_TAR_PATH"

            echo "Checking for existing container: $REMOTE_CONTAINER_NAME..."
            if [ "$(docker ps -q -f name="^/$REMOTE_CONTAINER_NAME$")" ]; then # More precise name matching
              echo "Stopping container $REMOTE_CONTAINER_NAME..."
              docker stop "$REMOTE_CONTAINER_NAME"
            fi
            if [ "$(docker ps -aq -f name="^/$REMOTE_CONTAINER_NAME$")" ]; then # More precise name matching
              echo "Removing container $REMOTE_CONTAINER_NAME..."
              docker rm "$REMOTE_CONTAINER_NAME"
            fi

            echo "Running new container $FULL_IMAGE_NAME_WITH_TAG as $REMOTE_CONTAINER_NAME on port $REMOTE_DROPLET_PORT..."
            docker run -d \
              --name "$REMOTE_CONTAINER_NAME" \
              --restart always \
              -p 80:"$REMOTE_DROPLET_PORT" \
              -e DATABASE_URL="$REMOTE_DATABASE_URL" \
              -e NODE_ENV="production" \
              "$FULL_IMAGE_NAME_WITH_TAG"

            # Optional: Clean up old, unused (dangling) Docker images to save space
            # Use with caution, especially if you might need to quickly roll back to an older image manually on the server
            # echo "Cleaning up dangling Docker images..."
            # docker image prune -af

            echo "--- Deployment on Droplet completed ---"