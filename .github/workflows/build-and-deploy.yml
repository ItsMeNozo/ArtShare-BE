name: Deploy NestJS App to DO Droplet via SCP

on:
  push:
    branches:
      - testdeploy

env:
  IMAGE_NAME: artshare-backend
  CONTAINER_NAME: artshare-app
  DROPLET_PORT: 3000
  DROPLET_TARGET_PATH: /opt/deploy_artifacts # Using persistent storage

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout source code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        id: build_image
        run: |
          IMAGE_TAG="${{ github.sha }}"
          echo "Building image: ${{ env.IMAGE_NAME }}:$IMAGE_TAG"
          docker build -t "${{ env.IMAGE_NAME }}:$IMAGE_TAG" .
          if [ $? -ne 0 ]; then echo "::error::Docker build failed!"; exit 1; fi
          echo "Docker build completed successfully."
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT

      - name: Save Docker image to tar
        id: save_tar
        run: |
          if [ -z "${{ steps.build_image.outputs.image_tag }}" ]; then echo "::error::Output 'image_tag' from build_image step is empty!"; exit 1; fi
          TAR_FILENAME="${{ env.IMAGE_NAME }}-${{ steps.build_image.outputs.image_tag }}.tar"
          echo "Debug: Constructed TAR_FILENAME = '$TAR_FILENAME'"
          if [ -z "$TAR_FILENAME" ] || [ "$TAR_FILENAME" == ".tar" ] || [ "$TAR_FILENAME" == "-.tar" ]; then echo "::error::TAR_FILENAME is empty or malformed: '$TAR_FILENAME'"; exit 1; fi
          
          echo "Saving image ${{ env.IMAGE_NAME }}:${{ steps.build_image.outputs.image_tag }} to $(pwd)/$TAR_FILENAME"
          docker save "${{ env.IMAGE_NAME }}:${{ steps.build_image.outputs.image_tag }}" -o "$TAR_FILENAME"
          SAVED_STATUS=$?
          if [ $SAVED_STATUS -ne 0 ]; then echo "::error::Docker save command failed with status $SAVED_STATUS!"; ls -lha .; exit $SAVED_STATUS; fi
          echo "Docker save completed successfully."
          
          echo "Verifying file existence and permissions for '$TAR_FILENAME' before chmod:"
          ls -lha "$TAR_FILENAME"
          if [ ! -f "$TAR_FILENAME" ]; then echo "::error::Tar file '$TAR_FILENAME' was NOT created by docker save!"; ls -lha .; exit 1; fi
          
          echo "Attempting: chmod 644 \"$TAR_FILENAME\""
          chmod 644 "$TAR_FILENAME"
          CHMOD_STATUS=$?
          if [ $CHMOD_STATUS -ne 0 ]; then echo "::error::chmod command failed with status $CHMOD_STATUS for file '$TAR_FILENAME'!"; ls -lha "$TAR_FILENAME"; exit $CHMOD_STATUS; fi
          echo "Set permissions (644) on $TAR_FILENAME successfully."
          
          # ====> ADDED SIZE CHECK <====
          echo "Size of saved tar file '$TAR_FILENAME':"
          ls -lh "$TAR_FILENAME" 
          
          echo "IMAGE_TAR_FILENAME_ENV=$TAR_FILENAME" >> $GITHUB_ENV

      - name: Verify tar file before SCP
        run: |
          echo "Current directory: $(pwd)"
          echo "Workspace contents:"
          ls -lha .
          echo "---"
          echo "Checking saved tar file from env: ${{ env.IMAGE_TAR_FILENAME_ENV }}"
          ls -lha "${{ env.IMAGE_TAR_FILENAME_ENV }}"
          if [ ! -f "${{ env.IMAGE_TAR_FILENAME_ENV }}" ]; then echo "::error::Tar file ${{ env.IMAGE_TAR_FILENAME_ENV }} not found before SCP!"; exit 1; fi
          echo "Tar file exists and permissions are listed above."

      - name: Copy Docker image tar to Droplet
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.DO_USER }} # Should be root as per your confirmation
          key: ${{ secrets.SSHKEY }}
          passphrase: ${{ secrets.SSH_KEY_PASSPHRASE }} # Ensure this secret is set if your key is passphrase protected
          source: "${{ env.IMAGE_TAR_FILENAME_ENV }}"
          target: "${{ env.DROPLET_TARGET_PATH }}"

      - name: Deploy on Droplet
        uses: appleboy/ssh-action@v1.0.3
        env:
          # These variables are set for the action's execution environment.
          # The script running on the remote server should inherit them.
          VAR_IMAGE_NAME: ${{ env.IMAGE_NAME }}
          VAR_CONTAINER_NAME: ${{ env.CONTAINER_NAME }}
          VAR_DROPLET_PORT: ${{ env.DROPLET_PORT }}
          VAR_TARGET_PATH_ON_DROPLET: ${{ env.DROPLET_TARGET_PATH }} # Renamed for clarity in debugging
          VAR_IMAGE_TAR_FILENAME: ${{ env.IMAGE_TAR_FILENAME_ENV }}
          VAR_IMAGE_TAG: ${{ steps.build_image.outputs.image_tag }}
          VAR_DATABASE_URL: ${{ secrets.DATABASE_URL }}
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.DO_USER }}
          key: ${{ secrets.SSHKEY }}
          passphrase: ${{ secrets.SSH_KEY_PASSPHRASE }} # Ensure this secret is set if your key is passphrase protected
          port: 22
          script: |
            set -e # Exit immediately if a command exits with a non-zero status

            echo "--- Starting deployment on Droplet ---"
            echo "--- Debugging Remote Environment Variables ---"
            echo "Value of VAR_TARGET_PATH_ON_DROPLET is: '$VAR_TARGET_PATH_ON_DROPLET'"
            echo "Value of VAR_IMAGE_TAR_FILENAME is: '$VAR_IMAGE_TAR_FILENAME'"
            echo "Value of VAR_IMAGE_TAG is: '$VAR_IMAGE_TAG'"
            echo "--------------------------------------------"

            # Explicitly check if the target path variable is empty
            if [ -z "$VAR_TARGET_PATH_ON_DROPLET" ]; then
              echo "::error:: Critical Error: VAR_TARGET_PATH_ON_DROPLET is empty on the remote server!"
              echo "This means the env var was not passed correctly to the SSH script."
              echo "Printing all 'VAR_' prefixed environment variables available to the script:"
              printenv | grep '^VAR_'
              exit 1
            fi

            echo "Ensuring target directory '$VAR_TARGET_PATH_ON_DROPLET' exists..."
            mkdir -p "$VAR_TARGET_PATH_ON_DROPLET"

            FULL_IMAGE_TAR_PATH="$VAR_TARGET_PATH_ON_DROPLET/$VAR_IMAGE_TAR_FILENAME"
            FULL_IMAGE_NAME_WITH_TAG="$VAR_IMAGE_NAME:$VAR_IMAGE_TAG" # Using VAR_IMAGE_NAME and VAR_IMAGE_TAG now

            echo "Current disk space on Droplet before load:"
            df -h "$VAR_TARGET_PATH_ON_DROPLET"
            df -h /

            echo "Loading Docker image from $FULL_IMAGE_TAR_PATH..."
            docker load -i "$FULL_IMAGE_TAR_PATH"

            echo "Removing Docker image tar file: $FULL_IMAGE_TAR_PATH..."
            rm "$FULL_IMAGE_TAR_PATH"

            echo "Checking for existing container: $VAR_CONTAINER_NAME..."
            if [ "$(docker ps -q -f name="^/$VAR_CONTAINER_NAME$")" ]; then
              echo "Stopping container $VAR_CONTAINER_NAME..."
              docker stop "$VAR_CONTAINER_NAME"
            fi
            if [ "$(docker ps -aq -f name="^/$VAR_CONTAINER_NAME$")" ]; then
              echo "Removing container $VAR_CONTAINER_NAME..."
              docker rm "$VAR_CONTAINER_NAME"
            fi

            echo "Running new container $FULL_IMAGE_NAME_WITH_TAG as $VAR_CONTAINER_NAME on port $VAR_DROPLET_PORT..."
            docker run -d \
              --name "$VAR_CONTAINER_NAME" \
              --restart always \
              -p 80:"$VAR_DROPLET_PORT" \
              -e DATABASE_URL="$VAR_DATABASE_URL" \
              -e NODE_ENV="production" \
              "$FULL_IMAGE_NAME_WITH_TAG"

            echo "--- Deployment on Droplet completed ---"